# -*- coding: utf-8 -*-
"""Graph_Analysis_Instagram.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YhIaaMAxVn-unhUKO-5W17RgCePepuIg
"""

!pip install networkx
!pip install pyg-nightly
!pip install scipy==1.8.1
!pip install -q grpcio
!pip install cdlib

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from random import randint

from google.colab import drive
drive.mount('/content/drive')
instagram = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/insta_data.txt",sep=" ",names=["start_node", "end_node"])
instagram

G = nx.from_pandas_edgelist(instagram, "start_node", "end_node")

n = len(G)
m = len(G.edges())
n, m

fig, ax = plt.subplots(figsize=(18, 10))
ax.axis("off")
plot_options = {"node_size": 10, "with_labels": False, "width": 0.15}
nx.draw_networkx(G, pos=nx.random_layout(G), ax=ax, **plot_options)

pos = nx.spring_layout(G)
betCent = nx.betweenness_centrality(G, normalized=True, endpoints=True)  # Calculate the betweenness centrality of each node in the graph
node_color = [20000.0 * G.degree(v) for v in G]  # Create a list of node colors based on the degree of each node
node_size =  [v * 1000 for v in betCent.values()] # Create a list of node sizes based on the betweenness centrality of each node
plt.figure(figsize=(14,10))
nx.draw_networkx(G, pos=pos, with_labels=False,# Draw the network graph using the spring layout, with no node labels, using the node color and size lists
                 node_color=node_color,
                 node_size=node_size )
plt.axis('off');

pos = nx.spring_layout(G)
betCent = nx.betweenness_centrality(G, normalized=True, endpoints=True)
node_color = [20000.0 * G.degree(v) for v in G]
node_size =  [v * 1000 for v in betCent.values()]
plt.figure(figsize=(15,13))
nx.draw_networkx(G, pos=pos, with_labels=False,
                 node_color=node_color,
                 node_size=node_size )
plt.axis('off');

G.number_of_nodes()

G.number_of_edges()

np.mean([d for _, d in G.degree()])

degree_centrality = nx.centrality.degree_centrality(G)
(sorted(degree_centrality.items(), key=lambda item: item[1], reverse=True))[:8]

node_size = [
    v * 1000 for v in degree_centrality.values()
]  # set up nodes size for a nice graph representation
plt.figure(figsize=(18, 12))
nx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)
plt.axis("off")

betweenness_centrality = nx.centrality.betweenness_centrality(
    G
)  # save results in a variable to use again
(sorted(betweenness_centrality.items(), key=lambda item: item[1], reverse=True))[:8]

instagram.info()

node_size = [v * 1000 for v in betweenness_centrality.values()]

# Get the top 5 nodes by betweenness centrality
top_nodes = sorted(betweenness_centrality.items(), key=lambda x: x[1], reverse=True)[:5]
top_node_labels = [node[0] for node in top_nodes]

node_size = [v * 1000 for k, v in betweenness_centrality.items() if k in top_node_labels]

plt.figure(figsize=(20, 13))
nx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15,
    nodelist=top_node_labels, node_color='r', alpha=0.8)
plt.axis("off")

import inspect

# Calculate the eigenvector centrality of each node
eigenCent = nx.eigenvector_centrality(G,max_iter=1000)
node_color = [20000.0 * G.degree(v) for v in G]
node_size =  [v * 1000 for v in eigenCent.values()]
plt.figure(figsize=(20,20))
nx.draw_networkx(G, pos=pos, with_labels=False,
                 node_color=node_color,
                 node_size=node_size )
plt.axis('off');
# Sort the nodes by their eigenvector centrality
sorted_nodes = sorted(eigenCent, key=eigenCent.get, reverse=True)
# Select the top 5 nodes
top_5_nodes = sorted_nodes[:5]
# Print the top 5 nodes
print(top_5_nodes)

node_size = [
    v * 1200 for v in eigenCent.values()
]  # set up nodes size for a nice graph representation
plt.figure(figsize=(15, 8))
nx.draw_networkx(G, pos=pos, node_size=node_size, with_labels=False, width=0.15)
plt.axis("off")

from cdlib import algorithms, viz
import networkx as nx 

coms =algorithms.louvain(G, weight='weight',resolution=1)

pos = nx.spring_layout(G)

viz.plot_network_clusters(G,coms, pos)
viz.plot_community_graph(G, coms)

#returns the number of communities in the graph.
len(coms.communities)

coms.communities